// G24
//   p06e.c   → eraP06e
//   p2pv.c   → eraP2pv
//   p2s.c    → eraP2s
//   pap.c    → eraPap
//   pas.c    → eraPas
//   pb06.c   → eraPb06
//   pdp.c    → eraPdp
//   pfw06.c  → eraPfw06
//   plan94.c → eraPlan94
//   pm.c     → eraPm
use crate::H1::*;

// eraP06e   Precession angles, IAU-2006, equinox based
pub unsafe fn eraP06e(
    date1: f64,
    date2: f64,
    eps0: *mut f64,
    psia: *mut f64,
    oma: *mut f64,
    bpa: *mut f64,
    bqa: *mut f64,
    pia: *mut f64,
    bpia: *mut f64,
    epsa: *mut f64,
    chia: *mut f64,
    za: *mut f64,
    zetaa: *mut f64,
    thetaa: *mut f64,
    pa: *mut f64,
    gam: *mut f64,
    phi: *mut f64,
    psi: *mut f64,
) {
    let t = ((date1 - ERFA_DJ00) + date2) / ERFA_DJC;

    *eps0 = 84381.406 * ERFA_DAS2R;

    *psia = (5038.481507
        + (-1.0790069 + (-0.00114045 + (0.000132851 + (-0.0000000951) * t) * t) * t) * t)
        * t
        * ERFA_DAS2R;

    *oma = *eps0
        + ((-0.025754
            + (0.0512623 + (-0.00772503 + (-0.000000467 + 0.0000003337 * t) * t) * t) * t)
            * t)
            * ERFA_DAS2R;

    *bpa = (4.199094 + (0.1939873 + (-0.00022466 + (-0.000000912 + 0.0000000120 * t) * t) * t) * t)
        * t
        * ERFA_DAS2R;

    *bqa = (-46.811015
        + (0.0510283 + (0.00052413 + (-0.000000646 + (-0.0000000172) * t) * t) * t) * t)
        * t
        * ERFA_DAS2R;

    *pia = (46.998973
        + (-0.0334926 + (-0.00012559 + (0.000000113 + (-0.0000000022) * t) * t) * t) * t)
        * t
        * ERFA_DAS2R;

    *bpia = (629_546.7936
        + (-867.95758 + (0.157992 + (-0.0005371 + (-0.00004797 + 0.000000072 * t) * t) * t) * t)
            * t)
        * ERFA_DAS2R;

    *epsa = eraObl06(date1, date2);

    *chia = (10.556403
        + (-2.3814292 + (-0.00121197 + (0.000170663 + (-0.0000000560) * t) * t) * t) * t)
        * t
        * ERFA_DAS2R;

    *za = (-2.650545
        + (2306.077181
            + (1.0927348 + (0.01826837 + (-0.000028596 + (-0.0000002904) * t) * t) * t) * t)
            * t)
        * ERFA_DAS2R;

    *zetaa = (2.650545
        + (2306.083227
            + (0.2988499 + (0.01801828 + (-0.000005971 + (-0.0000003173) * t) * t) * t) * t)
            * t)
        * ERFA_DAS2R;

    *thetaa = (2004.191903
        + (-0.4294934 + (-0.04182264 + (-0.000007089 + (-0.0000001274) * t) * t) * t) * t)
        * t
        * ERFA_DAS2R;

    *pa = (5028.796195
        + (1.1054348 + (0.00007964 + (-0.000023857 + (-0.0000000383) * t) * t) * t) * t)
        * t
        * ERFA_DAS2R;

    *gam = (10.556403
        + (0.4932044 + (-0.00031238 + (-0.000002788 + 0.0000000260 * t) * t) * t) * t)
        * t
        * ERFA_DAS2R;

    *phi = *eps0
        + ((-46.811015
            + (0.0511269 + (0.00053289 + (-0.000000440 + (-0.0000000176) * t) * t) * t) * t)
            * t)
            * ERFA_DAS2R;

    *psi = (5038.481507
        + (1.5584176 + (-0.00018522 + (-0.000026452 + (-0.0000000148) * t) * t) * t) * t)
        * t
        * ERFA_DAS2R;
}

// eraP2pv  Extend p-vector to pv-vector with zero velocity
pub unsafe fn eraP2pv(p: *mut f64, pv: *mut f64) {
    for i in 0..3 {
        *pv.add(i) = *p.add(i);
    }
    for i in 0..3 {
        *pv.add(3 + i) = 0.0;
    }
}

// eraP2s  p-vector → spherical coordinates
pub unsafe fn eraP2s(p: *mut f64, theta: *mut f64, phi: *mut f64, r: *mut f64) {
    eraC2s(p, theta, phi);
    *r = eraPm(p);
}

// eraPap  Position angle from two p-vectors
pub unsafe fn eraPap(a: *mut f64, b: *mut f64) -> f64 {
    let mut am = 0.0;
    let mut au = [0.0_f64; 3];
    eraPn(a, &mut am, au.as_mut_ptr());

    let bm = eraPm(b);

    let (st, ct) = if am == 0.0 || bm == 0.0 {
        (0.0, 1.0)
    } else {
        let xa = *a.add(0);
        let ya = *a.add(1);
        let za = *a.add(2);
        let eta = [-xa * za, -ya * za, xa * xa + ya * ya];

        let mut xi = [0.0_f64; 3];
        eraPxp(
            eta.as_ptr() as *mut f64,
            au.as_ptr() as *mut f64,
            xi.as_mut_ptr(),
        );

        let mut a2b = [0.0_f64; 3];
        eraPmp(b, a, a2b.as_mut_ptr());

        let st = eraPdp(a2b.as_ptr() as *mut f64, xi.as_ptr() as *mut f64);
        let mut ct = eraPdp(a2b.as_ptr() as *mut f64, eta.as_ptr() as *mut f64);
        if st == 0.0 && ct == 0.0 {
            ct = 1.0;
        }
        (st, ct)
    };

    st.atan2(ct)
}

// eraPas  Position angle from spherical coordinates
pub unsafe fn eraPas(al: f64, ap: f64, bl: f64, bp: f64) -> f64 {
    let dl = bl - al;
    let y = dl.sin() * bp.cos();
    let x = bp.sin() * ap.cos() - bp.cos() * ap.sin() * dl.cos();
    if x != 0.0 || y != 0.0 {
        y.atan2(x)
    } else {
        0.0
    }
}

// eraPb06  Precession-bias Euler angles, IAU-2006
pub unsafe fn eraPb06(date1: f64, date2: f64, bzeta: *mut f64, bz: *mut f64, btheta: *mut f64) {
    let mut r = [0.0_f64; 9];
    eraPmat06(date1, date2, r.as_mut_ptr());

    let mut y = r[1 * 3 + 2];
    let mut x = -r[0 * 3 + 2];
    if x < 0.0 {
        y = -y;
        x = -x;
    }
    *bz = if x != 0.0 || y != 0.0 {
        -y.atan2(x)
    } else {
        0.0
    };

    eraRz(*bz, r.as_mut_ptr());

    y = r[0 * 3 + 2];
    x = r[2 * 3 + 2];
    *btheta = if x != 0.0 || y != 0.0 {
        -y.atan2(x)
    } else {
        0.0
    };

    y = -r[1 * 3 + 0];
    x = r[1 * 3 + 1];
    *bzeta = if x != 0.0 || y != 0.0 {
        -y.atan2(x)
    } else {
        0.0
    };
}

// eraPdp  Dot product of two p-vectors
pub unsafe fn eraPdp(a: *mut f64, b: *mut f64) -> f64 {
    *a.add(0) * *b.add(0) + *a.add(1) * *b.add(1) + *a.add(2) * *b.add(2)
}

// eraPfw06  Fukushima-Williams angles, IAU-2006
pub unsafe fn eraPfw06(
    date1: f64,
    date2: f64,
    gamb: *mut f64,
    phib: *mut f64,
    psib: *mut f64,
    epsa: *mut f64,
) {
    let t = ((date1 - ERFA_DJ00) + date2) / ERFA_DJC;

    *gamb = (-0.052928
        + (10.556378
            + (0.4932044 + (-0.00031238 + (-0.000002788 + 0.0000000260 * t) * t) * t) * t)
            * t)
        * ERFA_DAS2R;

    *phib = (84_381.412819
        + (-46.811016
            + (0.0511268 + (0.00053289 + (-0.000000440 + (-0.0000000176) * t) * t) * t) * t)
            * t)
        * ERFA_DAS2R;

    *psib = (-0.041775
        + (5038.481484
            + (1.5584175 + (-0.00018522 + (-0.000026452 + (-0.0000000148) * t) * t) * t) * t)
            * t)
        * ERFA_DAS2R;

    *epsa = eraObl06(date1, date2);
}

// eraPm  Modulus of a p-vector
pub unsafe fn eraPm(p: *mut f64) -> f64 {
    (*p.add(0) * *p.add(0) + *p.add(1) * *p.add(1) + *p.add(2) * *p.add(2)).sqrt()
}

// eraPlan94  Approximate heliocentric p,v of planet (1-8)
pub unsafe fn eraPlan94(date1: f64, date2: f64, np_in: i32, pv: *mut f64) -> i32 {
    const GK: f64 = 0.017_202_098_950;
    const SINEPS: f64 = 0.397_777_155_931_913_7;
    const COSEPS: f64 = 0.917_482_062_069_181_8;
    const KMAX: i32 = 10;

    if np_in < 1 || np_in > 8 {
        for i in 0..6 {
            *pv.add(i) = 0.0;
        }
        return -1;
    }
    let np = (np_in - 1) as usize;

    let t = ((date1 - ERFA_DJ00) + date2) / ERFA_DJM;
    let mut jstat = if t.abs() <= 1.0 { 0 } else { 1 };

    const AMAS: [f64; 8] = [
        6023600.0, 408523.5, 328900.5, 3098710.0, 1047.355, 3498.5, 22869.0, 19314.0,
    ];
    const A: [[f64; 3]; 8] = [
        [0.3870983098, 0.0, 0.0],
        [0.7233298200, 0.0, 0.0],
        [1.0000010178, 0.0, 0.0],
        [1.5236793419, 3.0e-10, 0.0],
        [5.2026032092, 1.9132e-6, -3.9e-9],
        [9.5549091915, -2.13896e-5, 4.44e-8],
        [19.2184460618, -3.716e-6, 9.79e-9],
        [30.1103868694, -1.6635e-5, 6.86e-9],
    ];
    const DLM: [[f64; 3]; 8] = [
        [252.25090552, 5381016286.88982, -1.92789],
        [181.97980085, 2106641364.33548, 0.59381],
        [100.46645683, 1295977422.83429, -2.04411],
        [355.43299958, 689050774.93988, 0.94264],
        [34.35151874, 109256603.77991, -30.60378],
        [50.07744430, 43996098.55732, 75.61614],
        [314.05500511, 15424811.93933, -1.75083],
        [304.34866548, 7865503.20744, 0.21103],
    ];
    const E: [[f64; 3]; 8] = [
        [0.2056317526, 0.0002040653, -2.8349e-6],
        [0.0067719164, -0.0004776521, 9.8127e-6],
        [0.0167086342, -0.0004203654, -0.0000126734],
        [0.0934006477, 0.0009048438, -8.0641e-6],
        [0.0484979255, 0.0016322542, -0.0000471366],
        [0.0555481426, -0.0034664062, -0.0000643639],
        [0.0463812221, -0.0002729293, 7.8913e-6],
        [0.0094557470, 0.0000603263, 0.0],
    ];
    const PI_: [[f64; 3]; 8] = [
        [77.45611904, 5719.11590, -4.83016],
        [131.56370300, 175.48640, -498.48184],
        [102.93734808, 11612.35290, 53.27577],
        [336.06023395, 15980.45908, -62.32800],
        [14.33120687, 7758.75163, 259.95938],
        [93.05723748, 20395.49439, 190.25952],
        [173.00529106, 3215.56238, -34.09288],
        [48.12027554, 1050.71912, 27.39717],
    ];
    const DINC: [[f64; 3]; 8] = [
        [7.00498625, -214.25629, 0.28977],
        [3.39466189, -30.84437, -11.67836],
        [0.0, 469.97289, -3.35053],
        [1.84972648, -293.31722, -8.11830],
        [1.30326698, -71.55890, 11.95297],
        [2.48887878, 91.85195, -17.66225],
        [0.77319689, -60.72723, 1.25759],
        [1.76995259, 8.12333, 0.08135],
    ];
    const OMEGA: [[f64; 3]; 8] = [
        [48.33089304, -4515.21727, -31.79892],
        [76.67992019, -10008.48154, -51.32614],
        [174.87317577, -8679.27034, 15.34191],
        [49.55809321, -10620.90088, -230.57416],
        [100.46440702, 6362.03561, 326.52178],
        [113.66550252, -9240.19942, -66.23743],
        [74.00595701, 2669.15033, 145.93964],
        [131.78405702, -221.94322, -0.78728],
    ];
    const KP: [[i32; 9]; 8] = [
        [69613, 75645, 88306, 59899, 15746, 71087, 142173, 3086, 0],
        [21863, 32794, 26934, 10931, 26250, 43725, 53867, 28939, 0],
        [16002, 21863, 32004, 10931, 14529, 16368, 15318, 32794, 0],
        [6345, 7818, 15636, 7077, 8184, 14163, 1107, 4872, 0],
        [1760, 1454, 1167, 880, 287, 2640, 19, 2047, 1454],
        [574, 0, 880, 287, 19, 1760, 1167, 306, 574],
        [204, 0, 177, 1265, 4, 385, 200, 208, 204],
        [0, 102, 106, 4, 98, 1367, 487, 204, 0],
    ];
    const CA: [[i32; 9]; 8] = [
        [4, -13, 11, -9, -9, -3, -1, 4, 0],
        [-156, 59, -42, 6, 19, -20, -10, -12, 0],
        [64, -152, 62, -8, 32, -41, 19, -11, 0],
        [124, 621, -145, 208, 54, -57, 30, 15, 0],
        [-23437, -2634, 6601, 6259, -1507, -1821, 2620, -2115, -1489],
        [
            62911, -119919, 79336, 17814, -24241, 12068, 8306, -4893, 8902,
        ],
        [
            389061, -262125, -44088, 8387, -22976, -2093, -615, -9720, 6633,
        ],
        [-412235, -157046, -31430, 37817, -9740, -13, -7449, 9644, 0],
    ];
    const SA: [[i32; 9]; 8] = [
        [-29, -1, 9, 6, -6, 5, 4, 0, 0],
        [-48, -125, -26, -37, 18, -13, -20, -2, 0],
        [-150, -46, 68, 54, 14, 24, -28, 22, 0],
        [-621, 532, -694, -20, 192, -94, 71, -73, 0],
        [-14614, -19828, -5869, 1881, -4372, -2255, 782, 930, 913],
        [139737, 0, 24667, 51123, -5102, 7429, -4095, -1976, -9566],
        [
            -138081, 0, 37205, -49039, -41901, -33872, -27037, -12474, 18797,
        ],
        [0, 28492, 133236, 69654, 52322, -49577, -26430, -3593, 0],
    ];
    const KQ: [[i32; 10]; 8] = [
        [3086, 15746, 69613, 59899, 75645, 88306, 12661, 2658, 0, 0],
        [21863, 32794, 10931, 73, 4387, 26934, 1473, 2157, 0, 0],
        [10, 16002, 21863, 10931, 1473, 32004, 4387, 73, 0, 0],
        [10, 6345, 7818, 1107, 15636, 7077, 8184, 532, 10, 0],
        [19, 1760, 1454, 287, 1167, 880, 574, 2640, 19, 1454],
        [19, 574, 287, 306, 1760, 12, 31, 38, 19, 574],
        [4, 204, 177, 8, 31, 200, 1265, 102, 4, 204],
        [4, 102, 106, 8, 98, 1367, 487, 204, 4, 102],
    ];
    const CL: [[i32; 10]; 8] = [
        [21, -95, -157, 41, -5, 42, 23, 30, 0, 0],
        [-160, -313, -235, 60, -74, -76, -27, 34, 0, 0],
        [-325, -322, -79, 232, -52, 97, 55, -41, 0, 0],
        [2268, -979, 802, 602, -668, -33, 345, 201, -55, 0],
        [
            7610, -4997, -7689, -5841, -2617, 1115, -748, -607, 6074, 354,
        ],
        [
            -18549, 30125, 20012, -730, 824, 23, 1289, -352, -14767, -2062,
        ],
        [
            -135245, -14594, 4197, -4030, -5630, -2898, 2540, -306, 2939, 1986,
        ],
        [89948, 2103, 8963, 2695, 3682, 1648, 866, -154, -1963, -283],
    ];
    const SL: [[i32; 10]; 8] = [
        [-342, 136, -23, 62, 66, -52, -33, 17, 0, 0],
        [524, -149, -35, 117, 151, 122, -71, -62, 0, 0],
        [-105, -137, 258, 35, -116, -88, -112, -80, 0, 0],
        [854, -205, -936, -240, 140, -341, -97, -232, 536, 0],
        [-56980, 8016, 1012, 1448, -3024, -3710, 318, 503, 3767, 577],
        [
            138606, -13478, -4964, 1441, -1319, -1482, 427, 1236, -9167, -1918,
        ],
        [
            71234, -41116, 5334, -4935, -1848, 66, 434, -1748, 3780, -701,
        ],
        [-47645, 11647, 2166, 3194, 679, 0, -244, -419, -2531, 48],
    ];

    let mut da = A[np][0] + (A[np][1] + A[np][2] * t) * t;
    let mut dl = (3600.0 * DLM[np][0] + (DLM[np][1] + DLM[np][2] * t) * t) * ERFA_DAS2R;
    let de = E[np][0] + (E[np][1] + E[np][2] * t) * t;
    let dp = eraAnpm((3600.0 * PI_[np][0] + (PI_[np][1] + PI_[np][2] * t) * t) * ERFA_DAS2R);
    let di = (3600.0 * DINC[np][0] + (DINC[np][1] + DINC[np][2] * t) * t) * ERFA_DAS2R;
    let dom = eraAnpm((3600.0 * OMEGA[np][0] + (OMEGA[np][1] + OMEGA[np][2] * t) * t) * ERFA_DAS2R);

    let dmu = 0.35953620 * t;
    for k in 0..8 {
        let arga = KP[np][k] as f64 * dmu;
        let argl = KQ[np][k] as f64 * dmu;
        da += (CA[np][k] as f64 * arga.cos() + SA[np][k] as f64 * arga.sin()) * 1e-7;
        dl += (CL[np][k] as f64 * argl.cos() + SL[np][k] as f64 * argl.sin()) * 1e-7;
    }
    let arga = KP[np][8] as f64 * dmu;
    da += t * (CA[np][8] as f64 * arga.cos() + SA[np][8] as f64 * arga.sin()) * 1e-7;
    for k in 8..10 {
        let argl = KQ[np][k] as f64 * dmu;
        dl += t * (CL[np][k] as f64 * argl.cos() + SL[np][k] as f64 * argl.sin()) * 1e-7;
    }
    dl = dl.rem_euclid(ERFA_D2PI);

    let am = dl - dp;
    let mut ae = am + de * am.sin();
    let mut k_iter = 0;
    loop {
        let dae = (am - ae + de * ae.sin()) / (1.0 - de * ae.cos());
        ae += dae;
        k_iter += 1;
        if k_iter >= KMAX || dae.abs() <= 1e-12 {
            break;
        }
    }
    if k_iter >= KMAX {
        jstat = 2
    }

    let ae2 = ae * 0.5;
    let at = 2.0 * (((1.0 + de) / (1.0 - de)).sqrt() * ae2.sin()).atan2(ae2.cos());

    let r = da * (1.0 - de * ae.cos());
    let v = GK * ((1.0 + 1.0 / AMAS[np]) / (da * da * da)).sqrt();

    let si2 = (di * 0.5).sin();
    let xq = si2 * dom.cos();
    let xp = si2 * dom.sin();
    let tl = at + dp;
    let (xsw, xcw) = tl.sin_cos();
    let xm2 = 2.0 * (xp * xcw - xq * xsw);
    let xf = da / (1.0 - de * de).sqrt();
    let ci2 = (di * 0.5).cos();
    let xms = (de * dp.sin() + xsw) * xf;
    let xmc = (de * dp.cos() + xcw) * xf;
    let xpxq2 = 2.0 * xp * xq;

    let x = r * (xcw - xm2 * xp);
    let y = r * (xsw + xm2 * xq);
    let z = r * (-xm2 * ci2);

    *pv.add(0) = x;
    *pv.add(1) = y * COSEPS - z * SINEPS;
    *pv.add(2) = y * SINEPS + z * COSEPS;

    let xdot = v * ((-1.0 + 2.0 * xp * xp) * xms + xpxq2 * xmc);
    let ydot = v * ((1.0 - 2.0 * xq * xq) * xmc - xpxq2 * xms);
    let zdot = v * (2.0 * ci2 * (xp * xms + xq * xmc));

    *pv.add(3) = xdot;
    *pv.add(4) = ydot * COSEPS - zdot * SINEPS;
    *pv.add(5) = ydot * SINEPS + zdot * COSEPS;

    jstat
}
